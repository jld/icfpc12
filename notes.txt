Useful property: local state depends on a radius-n ball
(up/left/right) from t turns ago; e.g., can quickly check if a move
would result in robot squish.  Not quite as helpful for efficient map
storage, as arbitrarily much stuff can be in motion at once.

Problem: global properties matter; see, e.g., example 6.  Arbitrarily
complex falling rock stuff can break -- or make -- connectivity.  Can
track blame per-square for board state, but a little worried about
space consumption.

Further problem: how do we tell when we've broken lambda paths?  Could
keep shortest-path state, erase stuff leading out of a new rock, then
recompute at blank spaces & fixpoint.  Again, storage (although the
incremental rebuild would also work backwards).


Temptation: try to breed GAs to pattern-recognize this stuff.  Could
do more than just blind feedback -- monitor what happened when and be
more Lamarckian.  This has the benefit of being more fun than trying
to write a better Astar or whatever than people who work for Google.

Subproblem: what primitives to give them?  They need to be cheap, but
burning time stumbling around wildly is also not helpful.  Maybe I'll
give them undo as an action; let them run for some number of moves and
keep the least bad ending.

Strategic undo: How to find a useful implication point to back up to?
Don't want to keep bumbling around in a broad delta of suck.  Could
try to pattern-recognize checkpoints and undo points.

Metagame: am I hoping to run some evolution in response to the map?  I
think so.

Pattern idea:
  simple = [offset -> spacepred]
  fancy = simple | simple * (offsetnz * simple) * fancy

Want something that can recognize repeating patterns in one shot --
e.g., can we get out from under this rock shelf, or is it death?  On
the other hand, if we have a powerful enough undo, trying to
approximate the future like that might be more trouble than it's worth.

The important goal here, really, is to have something that's amenable
to mutation, and, especially, crossover.  (Let's not repeat 2003's
mistakes.)  

Now, the extra-fun question: will I ever want instant redo?  I'm
thinking the answer is "why not?"  (The other answer is that doing
reversible diff lists is being a "fun" way to learn how to use Rust's
region/typestate system.)

====

Thoughts on the fake-applicative array: would be nice to deforest some
of those intermediate nodes, especially because there are dead stores
in them and we might no longer even be keeping all the intermediate
steps for the real thing.

Fun thing I probably shouldn't try to do and might break everything:
write an unsafe function to dynamically check a shared box's refcount
and expose it as a unique/stack box if it's 1.  Sufficient version for
this: use the refcount in an advisory way.

But also: can compact if things are absolutely small, or if doing so
makes them not too much larger, or some other heuristic.  This should
all wait until I have something working, of course.

(Or even: when focusing, collect everything up to the old root, and
then swap.  That might be a win depending on the usage patterns, but
it's getting late.)

====

Anyway.  Ideas floating around in my head about a checkpoint cache,
and casting random paths off of them, and saving them on lambdas and
maybe randomly otherwise, and giving them decaying utilities and so
on.  

Collection of checkpoints with max size and sum of weights normalized
(or virtually normalized by maintaining sum); pick one randomly (by
weight?)... and then what?  Cast "standard paths"; yields collection
of new checkpoints.  Obviously want to score up ones that hit lambdas
(& consider how useful short paths might be), but lambdas followed by
death is less good.  Can't(?) dump them all into the pot; pick some
number by lot and add them with their scores, or something.

Consider some level of local search... ah.  If fewer than N available
points, we'll just add them all and remove the original.  Or, in
general, if we add k/n of the checkpoints, lower parent's score by
k/n.  (The root is, of course, outside everything and unremoveable.)
(May want to memoize checkpoints by string or something; or just not
care.)

Other things: quick check for whether a move is valid.  Rearrange the
"touched" to include whether/number rocks moved, to see whether "wait"
is useful.  (Or the entire point vector, but maybe that's too much
memory?  And I don't think we actually need that.)

Just single-direction rays, I think.  Ray in same direction as parent
is almost certainly not useful and could just be skipped.  Ray in
opposite direction is also probably not useful.  Could just skip
casting them with high probability.

Lite version: vector of states (posns); pick one and a useful move at
random; add result to end or replace random not-zero.

Write first: bot shell, that.

====

Agenda for Sunday: make submission work.  Then either the rule
extensions or the less awful bot.

In particular, selection pressure should be a win all by itself.

====


